name: Build LTSC ISO with Store

# Build Windows LTSC ISO with Microsoft Store support
# Supports Enterprise LTSC, IoT Enterprise LTSC, IoT Enterprise Subscription LTSC editions

on:
  workflow_call:
    inputs:
      iso_url:
        description: 'Windows LTSC ISO URL'
        required: false
        type: string
      edition:
        description: 'LTSC Edition to build'
        required: false
        default: 'IoT Enterprise LTSC'
        type: string
      add_store:
        description: 'Add Microsoft Store to ISO (default: yes)'
        required: false
        default: 'yes'
        type: string
      remove_defender:
        description: 'Remove Windows Defender (default: no)'
        required: false
        default: 'no'
        type: string
      remove_edge:
        description: 'Remove Microsoft Edge (default: yes)'
        required: false
        default: 'yes'
        type: string
      remove_ai:
        description: 'Remove AI/Copilot (default: no, LTSC typically does not have official AI support)'
        required: false
        default: 'no'
        type: string
      add_thorium:
        description: 'Add Thorium browser (independent of Edge removal, default: no)'
        required: false
        default: 'no'
        type: string
      iso_name:
        description: 'Custom ISO filename (leave empty to use default: ltsc-store.iso)'
        required: false
        type: string
  workflow_dispatch:
    inputs:
      iso_url:
        description: 'Windows LTSC ISO URL'
        required: false
        type: string
      edition:
        description: 'LTSC Edition to build'
        required: false
        default: 'IoT Enterprise LTSC'
        type: choice
        options:
          - Enterprise LTSC
          - IoT Enterprise LTSC
          - IoT Enterprise Subscription LTSC
      add_store:
        description: 'Add Microsoft Store to ISO'
        required: false
        default: true
        type: boolean
      remove_defender:
        description: 'Remove Windows Defender'
        required: false
        default: false
        type: boolean
      remove_edge:
        description: 'Remove Microsoft Edge'
        required: false
        default: true
        type: boolean
      remove_ai:
        description: 'Remove AI/Copilot (LTSC typically does not have official AI support)'
        required: false
        default: false
        type: boolean
      add_thorium:
        description: 'Add Thorium browser (independent of Edge removal)'
        required: false
        default: false
        type: boolean
      iso_name:
        description: 'Custom ISO filename (leave empty to use default: ltsc-store.iso)'
        required: false
        type: string

permissions:
  contents: read
  actions: read

jobs:
  build:
    runs-on: windows-2022
    timeout-minutes: 180

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup PowerShell and Environment
        shell: pwsh
        run: |
          $PSVersionTable
          Write-Host "PowerShell version: $($PSVersionTable.PSVersion)"
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          $PSDefaultParameterValues['*:ErrorAction'] = 'SilentlyContinue'

          Write-Host "=== System Information ===" -ForegroundColor Cyan
          Write-Host "CPU Cores: $env:NUMBER_OF_PROCESSORS"
          Write-Host "OS Version: $([System.Environment]::OSVersion.VersionString)"

          $drive = Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Used -gt 0 } | Select-Object -First 1
          if ($drive) {
            $freeSpaceGB = [math]::Round($drive.Free / 1GB, 2)
            Write-Host "Available disk space: $freeSpaceGB GB"
          }

          $env:DISM_MAX_THREADS = $env:NUMBER_OF_PROCESSORS
          Write-Host "DISM optimization: Max threads = $env:DISM_MAX_THREADS"

      - name: Download Microsoft Store Packages (fixed)
        shell: pwsh
        id: download-store
        env:
          ADD_STORE: ${{ github.event.inputs.add_store || inputs.add_store || 'yes' }}
        run: |
          # region helpers
          function Convert-ToYesNo {
            param($value, $default = 'yes')
            if (-not $value) { return $default }
            $str = $value.ToString().ToLower()
            if ($str -in @('true','1','yes','y')) { return 'yes' }
            return 'no'
          }

          function New-HttpHeaders {
            $h = @{ 'User-Agent' = 'tiny-auto-builder' }
            if ($env:GITHUB_TOKEN) { $h['Authorization'] = "Bearer $($env:GITHUB_TOKEN)" }
            return $h
          }

          function Get-RepoFiles {
            param([string]$ApiUrl)
            try {
              $r = Invoke-WebRequest -Uri $ApiUrl -UseBasicParsing -Headers (New-HttpHeaders) -ErrorAction Stop
              (($r.Content | ConvertFrom-Json) | Where-Object { $_.type -eq 'file' }).name
            } catch { @() }
          }

          function Resolve-FromList {
            param(
              [string]$Pattern,
              [string[]]$List
            )
            if (-not $List -or $List.Count -eq 0) { return $null }
            # Convert wildcard to regex and sort descending to prefer newer versions
            $regex = '^' + [Regex]::Escape($Pattern).Replace('\*','.*').Replace('\?','.') + '$'
            $List | Where-Object { $_ -match $regex } | Sort-Object -Descending | Select-Object -First 1
          }

          function Resolve-RepoFileName {
            param([string]$Pattern)
            $api = 'https://api.github.com/repos/namnguyen97x/LTSC-Add-Microsoft-Store/contents'
            $list = Get-RepoFiles -ApiUrl $api
            if ($list) { return (Resolve-FromList -Pattern $Pattern -List $list) }
            return $null
          }

          function Has-Wildcard {
            param([string]$Name)
            return ($Name -match '[\*\?\[\]]')
          }
          # endregion helpers

          $addStore = Convert-ToYesNo $env:ADD_STORE 'yes'
          $storeDir = "$env:GITHUB_WORKSPACE\StorePackages"

          if ($addStore -ne 'yes') {
            Write-Host "AddStore=$addStore, skipping Store packages download" -ForegroundColor Yellow
            New-Item -ItemType Directory -Force -Path $storeDir | Out-Null
            echo "STORE_PACKAGES_DIR=$storeDir" >> $env:GITHUB_ENV
            exit 0
          }

          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force -Path $storeDir | Out-Null

          Write-Host "=== Downloading Microsoft Store Packages ===" -ForegroundColor Cyan
          Write-Host "From: https://github.com/namnguyen97x/LTSC-Add-Microsoft-Store"

          # Required packages for Store to work (exact filenames are fine)
          $required = @(
            'Microsoft.NET.Native.Framework.2.2_2.2.29512.0_x64__8wekyb3d8bbwe.Appx',
            'Microsoft.NET.Native.Framework.2.2_2.2.29512.0_x86__8wekyb3d8bbwe.Appx',
            'Microsoft.NET.Native.Runtime.2.2_2.2.28604.0_x64__8wekyb3d8bbwe.Appx',
            'Microsoft.NET.Native.Runtime.2.2_2.2.28604.0_x86__8wekyb3d8bbwe.Appx',
            'Microsoft.UI.Xaml.2.8_8.2501.31001.0_x64__8wekyb3d8bbwe.Appx',
            'Microsoft.UI.Xaml.2.8_8.2501.31001.0_x86__8wekyb3d8bbwe.Appx',
            'Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64__8wekyb3d8bbwe.Appx',
            'Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x86__8wekyb3d8bbwe.Appx',
            'Microsoft.VCLibs.140.00_14.0.33519.0_x64__8wekyb3d8bbwe.Appx',
            'Microsoft.VCLibs.140.00_14.0.33519.0_x86__8wekyb3d8bbwe.Appx',
            # dynamic bundles (pattern -> will be resolved)
            'Microsoft.WindowsStore_*_neutral___8wekyb3d8bbwe.Msixbundle',
            'Microsoft.DesktopAppInstaller_*_neutral___8wekyb3d8bbwe.Msixbundle'
          )

          $optional = @(
            'Microsoft.StorePurchaseApp_*_neutral___8wekyb3d8bbwe.AppxBundle',
            'Microsoft.XboxIdentityProvider_*_neutral___8wekyb3d8bbwe.AppxBundle'
          )

          $baseUrl = 'https://github.com/namnguyen97x/LTSC-Add-Microsoft-Store/raw/master/'

          # Ensure aria2c
          $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
          if (-not $aria2) {
            $chocoAria2 = 'C:\\ProgramData\\choco\\bin\\aria2c.exe'
            if (Test-Path $chocoAria2) {
              $env:Path = "C:\\ProgramData\\choco\\bin;$env:Path"
              $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
            }
            if (-not $aria2) {
              Write-Host 'Installing aria2 via Chocolatey...'
              choco install aria2 -y --no-progress | Out-Host
              $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
            }
          }

          $failedRequired = @()
          $failedOptional = @()

          function Invoke-Download {
            param([string]$Url,[string]$OutFile)
            if ($aria2) {
              & aria2c --max-connection-per-server=8 --split=8 --dir=$storeDir --out=$OutFile $Url | Out-Host
            } else {
              Invoke-WebRequest -Uri $Url -OutFile (Join-Path $storeDir $OutFile) -UseBasicParsing -Headers (New-HttpHeaders)
            }
          }

          function Resolve-DynamicName {
            param([string]$Pattern)
            # 1) Try repo root contents
            $name = Resolve-RepoFileName -Pattern $Pattern
            if ($name) { return $name }
            # 2) Try Releases assets of the same repo (WindowsStore/AppInstaller)
            try {
              $rel = Invoke-WebRequest -Uri 'https://api.github.com/repos/namnguyen97x/LTSC-Add-Microsoft-Store/releases' -UseBasicParsing -Headers (New-HttpHeaders) -ErrorAction Stop
              $releases = $rel.Content | ConvertFrom-Json
              if ($releases) {
                $assets = @(); foreach ($r in ($releases | Select-Object -First 8)) { if ($r.assets) { $assets += $r.assets } }
                $candidate = Resolve-FromList -Pattern $Pattern -List ($assets.name)
                if ($candidate) { return $candidate }
              }
            } catch { }
            return $null
          }

          # Download function that guarantees no wildcard is sent
          function Get-File {
            param([string]$Name,[switch]$Optional)
            $targetName = $Name
            if (Has-Wildcard $Name) {
              $resolved = Resolve-DynamicName -Pattern $Name
              if ($resolved) { $targetName = $resolved }
              else {
                if ($Optional) { $script:failedOptional += $Name; Write-Host "  ⚠ Optional package not found by pattern: $Name" -ForegroundColor Yellow; return }
                $script:failedRequired += $Name; Write-Warning "  ✗ Required package unresolved: $Name"; return
              }
            }

            $dest = Join-Path $storeDir $targetName
            if (Test-Path $dest) { Write-Host "✓ $targetName already exists, skipping..." -ForegroundColor Green; return }
            $url = $baseUrl + $targetName
            Write-Host "Downloading: $targetName"
            try {
              Invoke-Download -Url $url -OutFile $targetName
              if (-not (Test-Path $dest)) { throw "File missing after download" }
              $sizeMB = [math]::Round((Get-Item $dest).Length/1MB,2)
              Write-Host "  ✓ Downloaded: $sizeMB MB" -ForegroundColor Green
            } catch {
              if ($Optional) { Write-Host "  ⚠ Optional package download failed: $targetName" -ForegroundColor Yellow; $script:failedOptional += $targetName }
              else { Write-Warning "  ✗ Failed to download required: $targetName"; $script:failedRequired += $targetName }
            }
          }

          # Prefer cloning repository and copying files locally to avoid per-file download failures
          # Skip direct downloads and mark all required as pending for clone/zip fallback
          $failedRequired = $required
          $failedOptional = @()

          # Fallbacks for unresolved/failed required bundles
          if ($failedRequired.Count -gt 0) {
            Write-Host "Some required packages failed to download, attempting local repo fallback..." -ForegroundColor Yellow

            $repoUrl = 'https://github.com/namnguyen97x/LTSC-Add-Microsoft-Store.git'
            $repoDir = Join-Path $env:RUNNER_TEMP 'LTSC-Add-Microsoft-Store'
            if (Test-Path $repoDir) { Remove-Item -Recurse -Force $repoDir }
            New-Item -ItemType Directory -Force -Path $repoDir | Out-Null

            $cloned = $false
            try {
              git --version | Out-Null
              Write-Host "Cloning repository: $repoUrl"
              git clone --depth=1 $repoUrl $repoDir | Out-Host
              if (Test-Path (Join-Path $repoDir '.git')) { $cloned = $true }
            } catch { Write-Host "git not available or clone failed: $_" -ForegroundColor Yellow }

            if (-not $cloned) {
              Write-Host 'Falling back to zip download...' -ForegroundColor Yellow
              $zipUrl = 'https://codeload.github.com/namnguyen97x/LTSC-Add-Microsoft-Store/zip/refs/heads/master'
              $zipPath = Join-Path $env:RUNNER_TEMP 'store.zip'
              Invoke-WebRequest -Uri $zipUrl -OutFile $zipPath -UseBasicParsing -Headers (New-HttpHeaders)
              Expand-Archive -Path $zipPath -DestinationPath $repoDir -Force
              $expanded = Get-ChildItem -Path $repoDir | Where-Object { $_.PSIsContainer } | Select-Object -First 1
              if ($expanded) { $repoDir = $expanded.FullName }
            }

            $stillMissing = @()
            foreach ($name in $failedRequired) {
              $pattern = if ($name -like 'Microsoft.WindowsStore*') { 'Microsoft.WindowsStore*_neutral___8wekyb3d8bbwe.*bundle' }
                         elseif ($name -like 'Microsoft.DesktopAppInstaller*') { 'Microsoft.DesktopAppInstaller*_8wekyb3d8bbwe.*bundle' }
                         else { $name }
              $m = Get-ChildItem -Path $repoDir -Recurse -Include $pattern -ErrorAction SilentlyContinue
              if ($m) {
                $pick = $m | Sort-Object Name -Descending | Select-Object -First 1
                Copy-Item -Path $pick.FullName -Destination (Join-Path $storeDir $pick.Name) -Force
                Write-Host "✓ Fallback copied: $($pick.Name)" -ForegroundColor Green
              } else { $stillMissing += $name }
            }

            if ($stillMissing.Count -gt 0) {
              Write-Host 'Required bundles still missing after clone/zip. Trying Releases assets...' -ForegroundColor Yellow
              try {
                $relUrl = 'https://api.github.com/repos/namnguyen97x/LTSC-Add-Microsoft-Store/releases'
                $relResp = Invoke-WebRequest -Uri $relUrl -UseBasicParsing -Headers (New-HttpHeaders) -ErrorAction Stop
                $releases = $relResp.Content | ConvertFrom-Json
                if ($releases) {
                  $assets = @(); foreach ($r in ($releases | Select-Object -First 5)) { if ($r.assets) { $assets += $r.assets } }
                  foreach ($pat in @('Microsoft.WindowsStore*_neutral___8wekyb3d8bbwe.*bundle','Microsoft.DesktopAppInstaller*_8wekyb3d8bbwe.*bundle')) {
                    $cand = $assets | Where-Object { $_.name -like $pat } | Sort-Object name -Descending | Select-Object -First 1
                    if ($cand -and $cand.browser_download_url) {
                      $outPath = Join-Path $storeDir $cand.name
                      Write-Host "Downloading from Releases: $($cand.name)" -ForegroundColor Cyan
                      Invoke-WebRequest -Uri $cand.browser_download_url -OutFile $outPath -UseBasicParsing -Headers (New-HttpHeaders)
                      if (Test-Path $outPath) { Write-Host "✓ Downloaded release asset: $($cand.name)" -ForegroundColor Green }
                    }
                  }
                }
              } catch { Write-Host "Warning: Failed to download from Releases: $_" -ForegroundColor Yellow }

              # Alternate sources
              Write-Host 'Trying alternate sources...' -ForegroundColor Yellow
              # 1) Desktop App Installer from winget-cli
              try {
                $wingetResp = Invoke-WebRequest -Uri 'https://api.github.com/repos/microsoft/winget-cli/releases' -UseBasicParsing -Headers (New-HttpHeaders) -ErrorAction Stop
                $wingetRel = $wingetResp.Content | ConvertFrom-Json
                if ($wingetRel) {
                  $wingetAssets = @(); foreach ($r in ($wingetRel | Select-Object -First 12)) { if ($r.assets) { $wingetAssets += $r.assets } }
                  $appx = $wingetAssets | Where-Object { $_.name -like 'Microsoft.DesktopAppInstaller*_8wekyb3d8bbwe*.msixbundle' } | Sort-Object name -Descending | Select-Object -First 1
                  if ($appx) {
                    $outPath = Join-Path $storeDir $appx.name
                    Write-Host "Downloading App Installer from winget-cli: $($appx.name)" -ForegroundColor Cyan
                    Invoke-WebRequest -Uri $appx.browser_download_url -OutFile $outPath -UseBasicParsing -Headers (New-HttpHeaders)
                    Write-Host '✓ Downloaded App Installer from winget-cli' -ForegroundColor Green
                  }
                }
              } catch { Write-Host "Warning: winget-cli fallback failed: $_" -ForegroundColor Yellow }

              # 2) Windows Store bundle from kkkgo repo
              try {
                $kk = Invoke-WebRequest -Uri 'https://api.github.com/repos/kkkgo/LTSC-Add-MicrosoftStore/contents' -UseBasicParsing -Headers @{ 'User-Agent' = 'tiny-auto-builder' } -ErrorAction Stop
                $kkFiles = $kk.Content | ConvertFrom-Json
                $storeFile = $kkFiles | Where-Object { $_.type -eq 'file' -and ($_.name -like 'Microsoft.WindowsStore*appxbundle' -or $_.name -like 'Microsoft.WindowsStore*msixbundle') } | Sort-Object name -Descending | Select-Object -First 1
                if ($storeFile) {
                  $outPath = Join-Path $storeDir $storeFile.name
                  Write-Host "Downloading Windows Store from kkkgo repo: $($storeFile.name)" -ForegroundColor Cyan
                  Invoke-WebRequest -Uri $storeFile.download_url -OutFile $outPath -UseBasicParsing
                  Write-Host '✓ Downloaded Windows Store from kkkgo repo' -ForegroundColor Green
                }
              } catch { Write-Host "Warning: kkkgo Store fallback failed: $_" -ForegroundColor Yellow }
            }
          }

          if ($failedOptional.Count -gt 0) {
            Write-Host "⚠ Some optional packages were not found (Store will still work): $($failedOptional -join ', ')" -ForegroundColor Yellow
          }

          Write-Host 'Store packages download completed!' -ForegroundColor Green
          echo "STORE_PACKAGES_DIR=$storeDir" >> $env:GITHUB_ENV

      - name: Cache Dependencies (ISO)
        uses: actions/cache@v4
        id: cache-iso
        with:
          path: |
            ${{ env.RUNNER_TEMP }}/windows-ltsc.iso
          key: ltsc-iso-cache-${{ runner.os }}-${{ hashFiles('**/*.yml') }}
          restore-keys: |
            ltsc-iso-cache-${{ runner.os }}-
        continue-on-error: true

      - name: Download and Mount Windows LTSC ISO
        shell: pwsh
        id: download-iso
        env:
          ISO_URL_INPUT: ${{ github.event.inputs.iso_url || inputs.iso_url || '' }}
        run: |
          $ErrorActionPreference = 'Stop'

          # Default LTSC ISO URL (Windows 11 Enterprise LTSC 2024)
          $defaultIsoUrl = 'https://ia804505.us.archive.org/29/items/windows_11_enterprise_ltsc_2024/en-us_windows_11_enterprise_ltsc_2024_x64_dvd_965cfb00.iso'

          $isoUrl = $env:ISO_URL_INPUT
          if (-not $isoUrl -or $isoUrl.Trim() -eq '') {
            Write-Host 'ISO URL not provided, using default LTSC ISO URL' -ForegroundColor Yellow
            $isoUrl = $defaultIsoUrl
          }

          Write-Host "Using ISO URL: $isoUrl" -ForegroundColor Cyan

          $isoFilePath = "$env:RUNNER_TEMP\windows-ltsc.iso"

          # Check if ISO already exists from cache
          if (Test-Path $isoFilePath) {
            $cachedSize = (Get-Item $isoFilePath).Length / 1GB
            Write-Host "✓ Using cached ISO file: $([math]::Round($cachedSize, 2)) GB" -ForegroundColor Green
          } else {
            Write-Host "Downloading Windows LTSC ISO from: $isoUrl"

            $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
            if (-not $aria2) {
              $chocoAria2 = 'C:\\ProgramData\\choco\\bin\\aria2c.exe'
              if (Test-Path $chocoAria2) {
                $env:Path = "C:\\ProgramData\\choco\\bin;$env:Path"
                $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
              }
              if (-not $aria2) { choco install aria2 -y --no-progress | Out-Host }
            }

            $aria2Args = @(
              '--max-connection-per-server=16',
              '--split=16',
              '--min-split-size=1M',
              '--timeout=60',
              '--retry-wait=3',
              '--max-tries=5',
              '--console-log-level=warn',
              '--summary-interval=5',
              '--file-allocation=none',
              "--dir=$($env:RUNNER_TEMP)",
              '--check-certificate=true',
              '--auto-file-renaming=false',
              "--out=$(Split-Path -Leaf $isoFilePath)",
              $isoUrl
            )

            Write-Host 'Downloading with aria2c...'
            & aria2c @aria2Args | Out-Host

            if (-not (Test-Path $isoFilePath)) { throw 'ISO file not found after download' }
            $fileSize = (Get-Item $isoFilePath).Length / 1GB
            Write-Host "✓ ISO downloaded: $([math]::Round($fileSize, 2)) GB" -ForegroundColor Green
          }

          Write-Host "Mounting ISO file: $isoFilePath"
          $mountResult = Mount-DiskImage -ImagePath $isoFilePath -PassThru -ErrorAction Stop
          $volume = $mountResult | Get-Volume
          $isoDriveLetter = $volume.DriveLetter

          if ($isoDriveLetter) {
            $isoDrive = "$isoDriveLetter:"
            Write-Host "✓ ISO mounted to: $isoDrive" -ForegroundColor Green
            echo "ISO_DRIVE=$isoDrive" >> $env:GITHUB_ENV
            echo "ISO_FILE_PATH=$isoFilePath" >> $env:GITHUB_ENV
          } else {
            Write-Error 'Failed to get drive letter from mounted ISO'
            exit 1
          }

      - name: Build LTSC ISO with Store
        shell: pwsh
        id: build
        env:
          EDITION: ${{ github.event.inputs.edition || inputs.edition || 'IoT Enterprise LTSC' }}
          ISO_NAME: ${{ github.event.inputs.iso_name || inputs.iso_name || 'ltsc-store.iso' }}
          ADD_STORE: ${{ github.event.inputs.add_store || inputs.add_store || 'yes' }}
          REMOVE_DEFENDER: ${{ github.event.inputs.remove_defender || inputs.remove_defender || 'no' }}
          REMOVE_EDGE: ${{ github.event.inputs.remove_edge || inputs.remove_edge || 'yes' }}
          REMOVE_AI: ${{ github.event.inputs.remove_ai || inputs.remove_ai || 'no' }}
          ADD_THORIUM: ${{ github.event.inputs.add_thorium || inputs.add_thorium || 'no' }}
        run: |
          $ErrorActionPreference = 'Continue'
          $buildStartTime = Get-Date

          function Get-PerformanceMetrics {
            $memInfo = Get-CimInstance Win32_OperatingSystem
            $cpu = Get-Counter '\Processor(_Total)\% Processor Time' -ErrorAction SilentlyContinue
            $freeMemGB = [math]::Round($memInfo.FreePhysicalMemory / 1MB, 2)
            $cpuPercent = if ($cpu) { [math]::Round($cpu.CounterSamples[0].CookedValue, 1) } else { 'N/A' }
            return @{ FreeMemoryGB = $freeMemGB; CPUPercent = $cpuPercent }
          }

          $isoDrive = $env:ISO_DRIVE
          if (-not $isoDrive) { Write-Error 'ISO drive not set'; exit 1 }

          function Convert-ToYesNo {
            param($value, $default = 'yes')
            if (-not $value) { return $default }
            $str = $value.ToString().ToLower()
            if ($str -in @('true','1','yes','y')) { return 'yes' }
            return 'no'
          }

          $edition = $env:EDITION
          $isoName  = if ($env:ISO_NAME) { $env:ISO_NAME } else { 'ltsc-store.iso' }
          $addStore = Convert-ToYesNo $env:ADD_STORE 'yes'
          $removeDefender = Convert-ToYesNo $env:REMOVE_DEFENDER 'no'
          $removeEdge = Convert-ToYesNo $env:REMOVE_EDGE 'yes'
          $removeAI = Convert-ToYesNo $env:REMOVE_AI 'no'
          $addThorium = Convert-ToYesNo $env:ADD_THORIUM 'no'

          $storeDir = $env:STORE_PACKAGES_DIR
          if (-not $storeDir -or -not (Test-Path $storeDir)) {
            if ($addStore -eq 'yes') { Write-Error 'Store packages directory not found (AddStore=yes but packages not downloaded)'; exit 1 }
            else { Write-Host 'AddStore=no, Store packages directory not needed' -ForegroundColor Gray; $storeDir = '' }
          }

          Write-Host '=== Build Configuration ===' -ForegroundColor Cyan
          Write-Host "ISO Drive: $isoDrive"
          Write-Host "Store Packages: $storeDir"
          Write-Host "Target Edition: $edition"
          Write-Host "ISO Name: $isoName"
          Write-Host "Debloat options: Defender=$removeDefender, AI=$removeAI, Edge=$removeEdge, AddStore=$addStore, Thorium=$addThorium" -ForegroundColor Cyan

          $scriptPath = Join-Path $env:GITHUB_WORKSPACE 'ltsc-store-builder.ps1'
          if (-not (Test-Path $scriptPath)) {
            Write-Error "LTSC builder script not found at: $scriptPath"
            Write-Host 'Available files in workspace:' -ForegroundColor Yellow
            Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter '*.ps1' | ForEach-Object { Write-Host "  - $($_.Name)" }
            exit 1
          }

          Write-Host '=== Starting Build Process ===' -ForegroundColor Cyan
          $metricsBefore = Get-PerformanceMetrics
          Write-Host "System metrics before build: CPU=$($metricsBefore.CPUPercent)%, Free RAM=$($metricsBefore.FreeMemoryGB) GB"

          try {
            $scriptOutput = & pwsh -File $scriptPath -DriveLetter $isoDrive -StorePackagesDir $storeDir -Edition $edition -IsoName $isoName -AddStore $addStore -RemoveDefender $removeDefender -RemoveEdge $removeEdge -RemoveAI $removeAI -AddThorium $addThorium -IrstDriverPath '' 2>&1
            foreach ($line in $scriptOutput) {
              Write-Host $line
              if ($line -match '^ISO_PATH=(.+)$') { $env:ISO_PATH = $Matches[1] }
              if ($line -match '^ISO_NAME=(.+)$') { $env:ISO_NAME = $Matches[1] }
              $now = Get-Date
              if (-not $script:lastMetricsTime -or ($now - $script:lastMetricsTime).TotalMinutes -ge 2) {
                $metrics = Get-PerformanceMetrics
                $elapsed = $now - $buildStartTime
                Write-Host "[Performance] [$([math]::Round($elapsed.TotalMinutes, 1)) min] CPU=$($metrics.CPUPercent)%, Free RAM=$($metrics.FreeMemoryGB) GB" -ForegroundColor Gray
                $script:lastMetricsTime = $now
              }
            }
            if ($LASTEXITCODE -ne 0) { Write-Warning "Script exited with code $LASTEXITCODE" }
          } catch { Write-Error "Error running script: $_"; exit 1 }

          if (-not $env:ISO_PATH) { $env:ISO_PATH = Join-Path $env:GITHUB_WORKSPACE $isoName }
          if (-not (Test-Path $env:ISO_PATH)) { Write-Error "ISO was not created at expected path: $env:ISO_PATH"; exit 1 }

          Write-Host "✓ ISO confirmed at: $env:ISO_PATH" -ForegroundColor Green
          echo "ISO_PATH=$env:ISO_PATH" >> $env:GITHUB_ENV

          $buildTime = (Get-Date) - $buildStartTime
          $metricsAfter = Get-PerformanceMetrics
          Write-Host '=== Build Summary ===' -ForegroundColor Cyan
          Write-Host "Build time: $([math]::Round($buildTime.TotalMinutes, 2)) minutes"
          Write-Host "System metrics after build: CPU=$($metricsAfter.CPUPercent)%, Free RAM=$($metricsAfter.FreeMemoryGB) GB"

      - name: Upload ISO Artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: ltsc-store-iso
          path: ${{ env.ISO_PATH }}
          retention-days: 30

      - name: Post-job Cleanup
        if: always()
        shell: pwsh
        run: |
          Write-Host 'Post job cleanup...'
          try { Start-Service -Name 'WSearch' -ErrorAction SilentlyContinue | Out-Null; Write-Host '✓ Windows Search service restored' -ForegroundColor Green } catch { Write-Host '  Info: Windows Search service restore skipped' -ForegroundColor Yellow }
          if ($env:ISO_FILE_PATH) {
            Write-Host "Unmounting ISO: $env:ISO_FILE_PATH"
            try {
              Get-DiskImage | Where-Object { $_.ImagePath -eq $env:ISO_FILE_PATH } | Dismount-DiskImage -ErrorAction Stop
              Write-Host '✓ ISO unmounted successfully' -ForegroundColor Green
            } catch { Write-Warning "Failed to unmount ISO: $_" }
          }
