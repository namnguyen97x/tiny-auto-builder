name: Build Tiny11 ISO (Optimized Experimental)

# EXPERIMENTAL VERSION - For testing optimizations
# This file contains experimental optimizations and should not replace build.yml
# Use workflow_dispatch to manually trigger this workflow

on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: false
        default: 'maker'
        type: choice
        options:
          - maker
          - core
          - nano
      iso_url:
        description: 'Windows ISO URL (leave empty to use default Windows 11 25H2 ISO)'
        required: false
        type: string
      version_selector:
        description: 'Windows edition to build (default: Auto - selects Pro)'
        required: false
        default: 'Auto'
        type: choice
        options:
          - Auto
          - Pro
          - Home
          - ProWorkstations
      remove_defender:
        description: 'Remove Windows Defender'
        required: false
        default: false
        type: boolean
      remove_ai:
        description: 'Remove AI/Copilot components'
        required: false
        default: true
        type: boolean
      remove_edge:
        description: 'Remove Microsoft Edge browser'
        required: false
        default: true
        type: boolean
      remove_store:
        description: 'Remove Microsoft Store'
        required: false
        default: true
        type: boolean
      remove_drivers:
        description: 'Remove non-essential drivers (NANO ONLY). Format: comma-separated list'
        required: false
        default: 'printer,scanner,bluetooth,smartcard,tape,rdp'
        type: string

permissions:
  contents: read
  actions: read

jobs:
  build:
    # Using Windows Server 2022 for better performance (typically faster than windows-latest)
    # windows-2022 is Windows Server 2022 which often has better I/O performance
    runs-on: windows-2022
    timeout-minutes: 180
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup PowerShell and Environment
        shell: pwsh
        run: |
          $PSVersionTable
          Write-Host "PowerShell version: $($PSVersionTable.PSVersion)"
          
          # Set PowerShell execution policy for this session
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          
          # Optimize PowerShell performance
          $PSDefaultParameterValues['*:ErrorAction'] = 'SilentlyContinue'
          
          # Display system information for monitoring
          Write-Host "=== System Information ===" -ForegroundColor Cyan
          Write-Host "CPU Cores: $env:NUMBER_OF_PROCESSORS"
          Write-Host "OS Version: $([System.Environment]::OSVersion.VersionString)"
          
          # Get disk information and optimize
          $drive = Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Used -gt 0 } | Select-Object -First 1
          if ($drive) {
            $freeSpaceGB = [math]::Round($drive.Free / 1GB, 2)
            Write-Host "Available disk space: $freeSpaceGB GB"
            
            # Check if running on SSD (faster disk) - GitHub Actions runners typically use SSD
            try {
              $disk = Get-PhysicalDisk | Where-Object { $_.DeviceID -eq 0 } | Select-Object -First 1
              if ($disk) {
                $mediaType = $disk.MediaType
                Write-Host "Disk type: $mediaType"
                if ($mediaType -eq 'SSD') {
                  Write-Host "✓ Running on SSD - optimized for fast I/O" -ForegroundColor Green
                }
              }
            } catch {
              Write-Host "  Info: Could not detect disk type (continuing...)" -ForegroundColor Yellow
            }
          }
          
          # Set environment variables for DISM optimization
          # These can help with parallel operations if scripts support them
          $env:DISM_MAX_THREADS = $env:NUMBER_OF_PROCESSORS
          Write-Host "DISM optimization: Max threads = $env:DISM_MAX_THREADS"
      
      - name: Cache Dependencies (ISO + Chocolatey packages)
        uses: actions/cache@v4
        id: cache-deps
        with:
          path: |
            ${{ env.RUNNER_TEMP }}/windows.iso
            C:\ProgramData\choco\cache
            C:\ProgramData\choco\bin\aria2c.exe
          key: deps-cache-${{ runner.os }}-v2
          restore-keys: |
            deps-cache-${{ runner.os }}-
            windows-iso-cache-
        continue-on-error: true
      
      - name: Download and Mount Windows ISO (Optimized)
        shell: pwsh
        id: download-iso
        env:
          ISO_URL_SECRET: ${{ secrets.ISO_URL }}
          ISO_URL_INPUT: ${{ github.event.inputs.iso_url }}
          DEFAULT_ISO_URL: 'https://software-static.download.prss.microsoft.com/dbazure/888969d5-f34g-4e03-ac9d-1f9786c66749/26200.6584.250915-1905.25h2_ge_release_svc_refresh_CLIENT_CONSUMER_x64FRE_en-us.iso'
        run: |
          $ErrorActionPreference = 'Stop'
          $startTime = Get-Date
          
          # Determine ISO source
          $isoUrl = $null
          if ($env:ISO_URL_INPUT -and $env:ISO_URL_INPUT.Trim() -ne '') {
            Write-Host "Using ISO URL from workflow input..."
            $isoUrl = $env:ISO_URL_INPUT.Trim()
          } elseif ($env:ISO_URL_SECRET -and $env:ISO_URL_SECRET.Trim() -ne '') {
            Write-Host "Using ISO URL from repository secret..."
            $isoUrl = $env:ISO_URL_SECRET.Trim()
          } else {
            Write-Host "Using default Windows 11 25H2 ISO URL..."
            $isoUrl = $env:DEFAULT_ISO_URL
          }
          
          $isoFilePath = "$env:RUNNER_TEMP\windows.iso"
          
          # Check if ISO already exists from cache
          if (Test-Path $isoFilePath) {
            $cachedSize = (Get-Item $isoFilePath).Length / 1GB
            Write-Host "✓ Using cached ISO file: $([math]::Round($cachedSize, 2)) GB" -ForegroundColor Green
          } else {
            Write-Host "Downloading Windows ISO from: $isoUrl"
            Write-Host "This may take a while depending on your connection speed..."
            
            try {
              # Check if aria2c is cached or available
              $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
              if (-not $aria2) {
                # Check if cached Chocolatey has aria2c
                $chocoAria2 = "C:\ProgramData\choco\bin\aria2c.exe"
                if (Test-Path $chocoAria2) {
                  Write-Host "✓ Using cached aria2c from Chocolatey" -ForegroundColor Green
                  $env:Path = "C:\ProgramData\choco\bin;$env:Path"
                  $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
                }
                
                if (-not $aria2) {
                  Write-Host "Installing aria2c via Chocolatey (will be cached for next run)..."
                  # Use --cache-location to use cached location
                  choco install aria2 -y --no-progress --cache-location="C:\ProgramData\choco\cache" | Out-Host
                  $aria2 = Get-Command aria2c -ErrorAction SilentlyContinue
                  if (-not $aria2) { throw "aria2c installation failed" }
                }
              } else {
                Write-Host "✓ aria2c already available" -ForegroundColor Green
              }
              
              # Optimized aria2c arguments for faster download
              # Increased connections and splits for better performance
              $aria2Args = @(
                '--max-connection-per-server=32',  # Increased from 16
                '--split=32',                       # Increased from 16
                '--min-split-size=1M',
                '--timeout=60',
                '--retry-wait=3',                  # Reduced from 5
                '--max-tries=5',
                '--console-log-level=warn',
                '--summary-interval=5',            # Show progress every 5 seconds
                '--file-allocation=none',          # Faster for large files
                "--dir=$($env:RUNNER_TEMP)",
                '--check-certificate=true',
                '--auto-file-renaming=false',
                "--out=$(Split-Path -Leaf $isoFilePath)",
                $isoUrl
              )
              
              Write-Host "Using optimized aria2c downloader (32 connections, 32 splits)..."
              & aria2c @aria2Args | Out-Host
              
              if (-not (Test-Path $isoFilePath)) { throw "ISO file not found after download" }
              $fileSize = (Get-Item $isoFilePath).Length
              if ($fileSize -lt 1000000) { throw "Downloaded file is unexpectedly small" }
              
              $downloadTime = (Get-Date) - $startTime
              $sizeGB = $fileSize / 1GB
              $speedMBps = $sizeGB / $downloadTime.TotalSeconds
              Write-Host "✓ ISO downloaded successfully" -ForegroundColor Green
              Write-Host "  Size: $([math]::Round($sizeGB, 2)) GB"
              Write-Host "  Time: $([math]::Round($downloadTime.TotalMinutes, 2)) minutes"
              Write-Host "  Average speed: $([math]::Round($speedMBps, 2)) MB/s"
            } catch {
              Write-Error "Failed to download ISO: $_"
              exit 1
            }
          }
          
          # Verify ISO file exists
          if (-not (Test-Path $isoFilePath)) {
            Write-Error "ISO file not found at: $isoFilePath"
            exit 1
          }
          
          $isoSize = (Get-Item $isoFilePath).Length / 1GB
          Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
          
          Write-Host "Mounting ISO file: $isoFilePath"
          
          # Mount ISO and get drive letter
          try {
            $mountResult = Mount-DiskImage -ImagePath $isoFilePath -PassThru -ErrorAction Stop
            $volume = $mountResult | Get-Volume
            $isoDriveLetter = $volume.DriveLetter
            
            if ($isoDriveLetter) {
              $isoDrive = "$isoDriveLetter`:"
              Write-Host "✓ ISO mounted successfully to drive: $isoDrive" -ForegroundColor Green
              echo "ISO_DRIVE=$isoDrive" >> $env:GITHUB_ENV
              echo "ISO_FILE_PATH=$isoFilePath" >> $env:GITHUB_ENV
            } else {
              Write-Error "Failed to get drive letter from mounted ISO"
              exit 1
            }
          } catch {
            Write-Error "Failed to mount ISO: $_"
            exit 1
          }
      
      - name: Optimize System Performance
        shell: pwsh
        run: |
          Write-Host "=== Optimizing System Performance ===" -ForegroundColor Cyan
          
          # Set PowerShell process priority to High (if possible)
          try {
            $process = Get-Process -Id $PID
            $process.PriorityClass = [System.Diagnostics.ProcessPriorityClass]::High
            Write-Host "✓ PowerShell process priority set to High" -ForegroundColor Green
          } catch {
            Write-Host "  Warning: Could not set process priority (may require admin)" -ForegroundColor Yellow
          }
          
          # Optimize disk performance for SSD
          Write-Host "Optimizing disk I/O performance..."
          try {
            # Disable Windows Search indexing temporarily (may speed up file operations)
            Stop-Service -Name "WSearch" -ErrorAction SilentlyContinue
            Write-Host "✓ Windows Search service stopped" -ForegroundColor Green
          } catch {
            Write-Host "  Info: Windows Search service management skipped" -ForegroundColor Yellow
          }
          
          # Optimize disk write cache for faster I/O (if on SSD)
          try {
            # Enable write caching if supported (typically enabled on SSD)
            $disk = Get-PhysicalDisk | Where-Object { $_.DeviceID -eq 0 } | Select-Object -First 1
            if ($disk -and $disk.MediaType -eq 'SSD') {
              Write-Host "✓ SSD detected - write caching should be optimal" -ForegroundColor Green
            }
          } catch {
            Write-Host "  Info: Disk optimization check skipped" -ForegroundColor Yellow
          }
          
          # Optimize PowerShell for better I/O
          try {
            # Increase buffer sizes for better performance
            $Host.UI.RawUI.BufferSize = New-Object Management.Automation.Host.Size(200, 9999)
          } catch {
            # Ignore if not supported
          }
          
          # Display available memory
          $memInfo = Get-CimInstance Win32_OperatingSystem
          $freeMemGB = [math]::Round($memInfo.FreePhysicalMemory / 1MB, 2)
          Write-Host "Available RAM: $freeMemGB GB"
          
          # Note about DISM parallelization
          Write-Host "Note: DISM operations run sequentially in scripts." -ForegroundColor Yellow
          Write-Host "      For parallel DISM operations, scripts need to be modified." -ForegroundColor Yellow
          Write-Host "      This workflow optimizes system-level performance only." -ForegroundColor Yellow
      
      - name: Build Tiny11 ISO (Optimized with Monitoring)
        shell: pwsh
        env:
          BUILD_TYPE: ${{ github.event.inputs.build_type || 'maker' }}
          VERSION_SELECTOR: ${{ github.event.inputs.version_selector || 'Auto' }}
          REMOVE_DEFENDER: ${{ github.event.inputs.remove_defender || 'false' }}
          REMOVE_AI: ${{ github.event.inputs.remove_ai || 'true' }}
          REMOVE_EDGE: ${{ github.event.inputs.remove_edge || 'true' }}
          REMOVE_STORE: ${{ github.event.inputs.remove_store || 'true' }}
          REMOVE_DRIVERS: ${{ github.event.inputs.remove_drivers || 'printer,scanner,bluetooth,smartcard,tape,rdp' }}
        run: |
          $ErrorActionPreference = 'Continue'
          $script:buildFailed = $false
          $script:buildError = $null
          $buildStartTime = Get-Date
          
          # Performance monitoring function
          function Get-PerformanceMetrics {
            $memInfo = Get-CimInstance Win32_OperatingSystem
            $cpu = Get-Counter '\Processor(_Total)\% Processor Time' -ErrorAction SilentlyContinue
            $freeMemGB = [math]::Round($memInfo.FreePhysicalMemory / 1MB, 2)
            $cpuPercent = if ($cpu) { [math]::Round($cpu.CounterSamples[0].CookedValue, 1) } else { "N/A" }
            return @{
              FreeMemoryGB = $freeMemGB
              CPUPercent = $cpuPercent
            }
          }
          
          # Get ISO drive from mounted ISO
          $isoDrive = $env:ISO_DRIVE
          if (-not $isoDrive) {
            Write-Error "ISO drive not set. Mount step may have failed."
            exit 1
          }
          
          $scratchDrive = $PSScriptRoot
          
          Write-Host "=== Build Configuration ===" -ForegroundColor Cyan
          Write-Host "ISO Drive: $isoDrive"
          Write-Host "Scratch Drive: $scratchDrive"
          Write-Host "Build Type: $env:BUILD_TYPE"
          Write-Host "DISM Max Threads: $env:DISM_MAX_THREADS (if supported by scripts)"
          
          # Build arguments
          $buildParams = @{}
          
          # Extract drive letter
          if ($isoDrive -match '^([A-Z]):$') {
            $buildParams['ISO'] = $Matches[1]
          } else {
            Write-Error "Invalid ISO drive format: $isoDrive"
            exit 1
          }
          
          # Determine script to run
          $buildType = $env:BUILD_TYPE
          $scriptName = switch ($buildType) {
            'core' { 'tiny11Coremaker.ps1' }
            'nano' { 'nano11maker.ps1' }
            default { 'tiny11maker.ps1' }
          }
          
          # Add NonInteractive flag
          $buildParams['NonInteractive'] = $true
          
          # Add version selector
          $versionSelector = if ($env:VERSION_SELECTOR) { $env:VERSION_SELECTOR } else { 'Auto' }
          $buildParams['VersionSelector'] = $versionSelector
          Write-Host "Version selector: $versionSelector"
          
          # Helper function to convert boolean/string to yes/no
          function Convert-ToYesNo {
            param($value, $default = 'yes')
            if (-not $value) { return $default }
            $str = $value.ToString().ToLower()
            if ($str -eq 'true' -or $str -eq '1' -or $str -eq 'yes') { return 'yes' }
            return 'no'
          }
          
          # Add debloat parameters
          Write-Host "Adding debloat parameters..."
          $buildParams['RemoveDefender'] = Convert-ToYesNo $env:REMOVE_DEFENDER 'no'
          $buildParams['RemoveAI'] = Convert-ToYesNo $env:REMOVE_AI 'yes'
          $buildParams['RemoveEdge'] = Convert-ToYesNo $env:REMOVE_EDGE 'yes'
          $buildParams['RemoveStore'] = Convert-ToYesNo $env:REMOVE_STORE 'yes'
          
          # Add driver removal parameters (NANO ONLY)
          if ($buildType -eq 'nano') {
            $driverRemoveStr = if ($env:REMOVE_DRIVERS) { $env:REMOVE_DRIVERS.Trim().ToLower() } else { 'all' }
            if ($driverRemoveStr -eq 'all' -or $driverRemoveStr -eq '') {
              $driverRemoveStr = 'printer,scanner,bluetooth,smartcard,tape,rdp'
            }
            $driverList = $driverRemoveStr -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
            $buildParams['RemovePrinterDrivers'] = if ($driverList -contains 'printer') { 'yes' } else { 'no' }
            $buildParams['RemoveScannerDrivers'] = if ($driverList -contains 'scanner') { 'yes' } else { 'no' }
            $buildParams['RemoveBluetoothDrivers'] = if ($driverList -contains 'bluetooth') { 'yes' } else { 'no' }
            $buildParams['RemoveSmartcardDrivers'] = if ($driverList -contains 'smartcard') { 'yes' } else { 'no' }
            $buildParams['RemoveTapeDrivers'] = if ($driverList -contains 'tape') { 'yes' } else { 'no' }
            $buildParams['RemoveRdpDrivers'] = if ($driverList -contains 'rdp') { 'yes' } else { 'no' }
            Write-Host "Driver removal options (nano): Printer=$($buildParams['RemovePrinterDrivers']), Scanner=$($buildParams['RemoveScannerDrivers']), Bluetooth=$($buildParams['RemoveBluetoothDrivers']), Smartcard=$($buildParams['RemoveSmartcardDrivers']), Tape=$($buildParams['RemoveTapeDrivers']), RDP=$($buildParams['RemoveRdpDrivers'])"
          }
          
          Write-Host "Debloat options ($buildType): Defender=$($buildParams['RemoveDefender']), AI=$($buildParams['RemoveAI']), Edge=$($buildParams['RemoveEdge']), Store=$($buildParams['RemoveStore'])"
          
          Write-Host "=== Starting Build Process ===" -ForegroundColor Cyan
          Write-Host "Script: $scriptName"
          Write-Host "Parameters: ISO=$($buildParams['ISO']), NonInteractive=$($buildParams['NonInteractive']), VersionSelector=$($buildParams['VersionSelector'])"
          
          # Monitor performance before build
          $metricsBefore = Get-PerformanceMetrics
          Write-Host "System metrics before build: CPU=$($metricsBefore.CPUPercent)%, Free RAM=$($metricsBefore.FreeMemoryGB) GB"
          
          # Run the builder script with performance monitoring
          try {
            # Run script directly with output filtering
            & ".\$scriptName" @buildParams 2>&1 | ForEach-Object {
              if ($_ -match "Removal failed|Warning.*Failed to remove") {
                Write-Warning $_
              } else {
                Write-Host $_
              }
              
              # Periodically show performance metrics
              $now = Get-Date
              if (-not $script:lastMetricsTime -or ($now - $script:lastMetricsTime).TotalMinutes -ge 5) {
                $metrics = Get-PerformanceMetrics
                $elapsed = $now - $buildStartTime
                Write-Host "[Performance] [$([math]::Round($elapsed.TotalMinutes, 1)) min] CPU=$($metrics.CPUPercent)%, Free RAM=$($metrics.FreeMemoryGB) GB" -ForegroundColor Gray
                $script:lastMetricsTime = $now
              }
            }
            
            # Check exit code
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Script exited with code $LASTEXITCODE, but continuing to check for ISO..."
            }
          } catch {
            Write-Warning "Error running script: $($_.Exception.Message)"
            $script:buildFailed = $true
            $script:buildError = $_
          }
          
          # Check if ISO was created
          $isoName = switch ($buildType) {
            'core' { 'tiny11-core.iso' }
            'nano' { 'nano11.iso' }
            default { 'tiny11.iso' }
          }
          $repoRoot = $env:GITHUB_WORKSPACE
          $isoPath = Join-Path $repoRoot $isoName
          
          $buildTime = (Get-Date) - $buildStartTime
          $metricsAfter = Get-PerformanceMetrics
          
          Write-Host "=== Build Summary ===" -ForegroundColor Cyan
          Write-Host "Build time: $([math]::Round($buildTime.TotalMinutes, 2)) minutes"
          Write-Host "System metrics after build: CPU=$($metricsAfter.CPUPercent)%, Free RAM=$($metricsAfter.FreeMemoryGB) GB"
          
          if (Test-Path $isoPath) {
            $isoSize = (Get-Item $isoPath).Length / 1GB
            Write-Host "✓ ISO created successfully: $isoPath" -ForegroundColor Green
            Write-Host "  Size: $([math]::Round($isoSize, 2)) GB"
            Write-Host "  Total build time: $([math]::Round($buildTime.TotalMinutes, 2)) minutes"
            exit 0
          } else {
            Write-Error "ISO was not created at expected path: $isoPath"
            if ($script:buildError) {
              Write-Error "Build error: $($script:buildError.Exception.Message)"
            }
            exit 1
          }
      
      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: ${{ github.event.inputs.build_type || 'maker' }}-iso-optimized
          path: |
            tiny11.iso
            tiny11-core.iso
            nano11.iso
            *.log
          retention-days: 7
          compression-level: 0
      
      - name: Cleanup and Restore Services
        if: always()
        shell: pwsh
        env:
          ISO_FILE_PATH: ${{ env.ISO_FILE_PATH }}
        run: |
          # Restore Windows Search service
          try {
            Start-Service -Name "WSearch" -ErrorAction SilentlyContinue
            Write-Host "✓ Windows Search service restored" -ForegroundColor Green
          } catch {
            Write-Host "  Info: Windows Search service restore skipped" -ForegroundColor Yellow
          }
          
          # Unmount ISO if we mounted it
          if ($env:ISO_FILE_PATH) {
            Write-Host "Unmounting ISO: $env:ISO_FILE_PATH"
            try {
              Get-DiskImage | Where-Object { $_.ImagePath -eq $env:ISO_FILE_PATH } | Dismount-DiskImage -ErrorAction Stop
              Write-Host "✓ ISO unmounted successfully" -ForegroundColor Green
            } catch {
              Write-Warning "Failed to unmount ISO: $_"
            }
            
            # Cleanup temporary ISO file if it was downloaded (not cached)
            if ($env:ISO_FILE_PATH -like "*RUNNER_TEMP*" -and -not (Test-Path "$env:RUNNER_TEMP\windows.iso.cache")) {
              Write-Host "Removing temporary ISO file..."
              Remove-Item -Path $env:ISO_FILE_PATH -Force -ErrorAction SilentlyContinue
            }
          }


